import EventEmitter from 'events'
import FB from './FB'
import _ from 'lodash'
import User from './models/User'
import Article from './models/Article'
import co from 'co'
import RiveScript from 'rivescript'
import natural from 'natural'

let bot = new RiveScript()
bot.loadDirectory('brain', () => {
  bot.sortReplies()
})

bot.setSubroutine('quickReply', (rs, [text]) => {
  let currentUser = rs.currentUser()
  let vars = rs.getUservars(currentUser)
  let quickReplies = vars.quickReplies || []
  quickReplies.push(text)
  rs.setUservars(currentUser, {quickReplies: quickReplies})
  console.log('quickReply', text)
  return ''
})

bot.setSubroutine('articles', (rs, ids) => {
  let currentUser = rs.currentUser()
  let vars = rs.getUservars(currentUser)
  return new rs.Promise((resolve, reject) => {
    co(function*() {
      let articles = yield ids.map((id) => return Article.find(id))
      rs.setUservars(currentUser, {
        articles: articles.map((a) => return a.val())
      })
      resolve('')
    })
  })
})

const EVENT_TYPES = ['message']
const CONTEXT_FLAGS = ['replyType', 'quickReplies', 'articles']
const BOT_WPM = 300

class Messaging extends EventEmitter {
  constructor() {
    super()
    this.on('webhook', this.onWebhook.bind(this))
    this.on('message', this.onMessage.bind(this))
    this.on('send', this.onSend.bind(this))
  }

  onWebhook(payload) {
    let entries = payload.entry
    if (entries == null) return
    entries.forEach((entry) => {
      let messaging = entry.messaging
      if (messaging == null) return
      messaging.forEach((event) => {
        for (let type of EVENT_TYPES) {
          if (event[type]) {
            this.emit(type, event)
            return
          }
        }
      })
    })
  }

  onMessage(message) {
    let messaging = this
    co(function* () {
      let text = _.get(message, 'message.text')
      let senderId = _.get(message, 'sender.id')

      console.log(`${senderId} >> ${text}`)

      let user = yield User.findWithFbid(senderId)
      console.log('user', user)
      let contextWrapper = yield user.context()
      console.log('context', contextWrapper)
      let startContext = contextWrapper.val()

      bot.clearUservars(user.id)
      bot.setUservars(user.id, startContext)
      let reply = yield bot.replyAsync(user.id, text)

      let endContext = bot.getUservars(user.id)

      console.log('end context', endContext)

      switch (endContext.replyType) {
        case 'text':
          messaging.sendText(user.id, reply, endContext.quickReplies)
          break
      }

      let updatedContext = _.omit(endContext, CONTEXT_FLAGS)

      yield contextWrapper.set(updatedContext)
    }).catch(console.error)
  }

  sendArticles(id, articles) {
    let messaging = this
    messaging.emit('send', {
      recipient: {id:id},
      message: {
        attachment: {
          type: "template",
          payload: {
            template_type: "generic",
            elements: articles.map((article) => {
              return {
                title: article.title,
                image_url: article.image,
                subtitle: article.description,
                buttons: [
                  {
                    type: "web_url",
                    url: article.canonicalLink,
                    title: "View Article"
                  }
                ]
              }
            })
          }
        }
      }
    })
  }

  sendText(id, text, quickReplies) {
    let messaging = this
    let lines = text.trim().split('\n')

    console.log('send text', ...arguments)

    if (quickReplies) quickReplies = quickReplies.map((quickReply) => {
      return {
        content_type: 'text',
        title: quickReply,
        payload: quickReply
      }
    })

    console.log('replies', quickReplies)

    var cumulativeDelay = 0
    for (var l = 0; l < lines.length; l++) {
      let line = lines[l]
      let wordLength = (new natural.WordTokenizer()).tokenize(line).length
      let lineDelay = wordLength / BOT_WPM * 60 * 1000
      messaging.send({
        recipient: {id:id},
        message: {
          text: line,
          quick_replies: l == lines.length - 1 ? quickReplies : null
        }
      }, cumulativeDelay += lineDelay)
    }
  }

  send(message, delay=0) {
    setTimeout(() => {
      this.emit('send', message)
    }, delay)
  }

  onSend(message) {
    co(function*() {
      console.log('SEND', message)
      let res = yield FB.api('/me/messages', 'post', message)
      console.log(res)
    }).catch(console.error)
  }
}

export default new Messaging()
